[IlPl123454/storage](https://github.com/IlPl123454/cloud-storage)
## ХОРОШО

1. **Использование records для immutable DTO** — `UserDto`, `ErrorDto`, `UserSignInRequestDto` реализованы как records, что соответствует best practices Java.

2. **Профили окружения** — есть разделение настроек для dev и prod окружений (application-dev.yml, application-prod.yml).

## ЗАМЕЧАНИЯ

### Пакет /config

1. **Класс LogMessage не является конфигурацией**

Класс `LogMessage` находится в пакете `config`, но по сути это набор строковых констант для логирования. Это нарушает принцип SRP — пакет config должен содержать только Spring конфигурационные классы с бинами и настройками.

 нарушается семантика пакета, снижается читаемость структуры проекта. Разработчик ожидает увидеть в `config` только Spring @Configuration классы.

**Рекомендация:**

```java
// Переместить в пакет constants или messages
package com.plenkov.cloudstorage.constants;

public final class LogMessages {
    private LogMessages() {
        throw new UnsupportedOperationException("Utility class");
    }
    
    public static final String LOG_FILE_ALREADY_EXIST = "...";
    // остальные константы
}
```

2. **MinioClientConfig не вынесен в отдельный properties класс**

В `MinioClientConfig` используется `@Value` для инъекции свойств напрямую в поля класса. При росте количества настроек MinIO это усложнит поддержку.

 нарушается Single Responsibility — класс отвечает и за чтение свойств, и за создание бина. Сложно переиспользовать конфигурацию MinIO в других местах. Нет валидации обязательности свойств при старте приложения.

**Рекомендация:**

```java
@ConfigurationProperties(prefix = "spring.minio")
@Validated
public class MinioProperties {
    @NotBlank
    private String url;
    @NotBlank
    private String accessKey;
    @NotBlank
    private String secretKey;
    @NotBlank
    private String bucketName;
    
    // getters/setters
}

@Configuration
@EnableConfigurationProperties(MinioProperties.class)
public class MinioClientConfig {
    @Bean
    public MinioClient minioClient(MinioProperties properties) {
        return MinioClient.builder()
                .endpoint(properties.getUrl())
                .credentials(properties.getAccessKey(), properties.getSecretKey())
                .build();
    }
}
```

3. **MinioBucketInit имеет проблемы с обработкой ошибок**

Метод `init()` с аннотацией `@PostConstruct` выбрасывает `MinioStorageException` при ошибке. Это приведёт к падению всего приложения при старте, даже если MinIO временно недоступен.

 приложение не сможет стартовать, если MinIO недоступен в момент запуска. Нет graceful degradation. При проблемах с MinIO во время инициализации разработчик получит неинформативный стектрейс.

**Рекомендация:**

```java
@PostConstruct
public void init() {
    try {
        if (!isBucketExists(bucketName)) {
            createBucket(bucketName);
            log.info("Bucket {} successfully created", bucketName);
        } else {
            log.info("Bucket {} already exists", bucketName);
        }
    } catch (MinioStorageException e) {
        log.error("Failed to initialize MinIO bucket: {}. Application may not work correctly", 
                  bucketName, e);
        // В зависимости от бизнес-требований можно:
        // - перевыбросить исключение если MinIO критичен
        // - или продолжить работу с логированием ошибки
        throw new IllegalStateException("MinIO initialization failed", e);
    }
}
```

4. **RedisConfig пустой класс без реальной конфигурации**

Класс `RedisConfig` содержит только аннотацию `@EnableRedisHttpSession` и пустой. Это избыточная абстракция, которая не добавляет ценности.

 пустые классы-маркеры усложняют навигацию по коду без видимой пользы. Конфигурация Redis полностью в YAML, класс не несёт дополнительной логики.

**Рекомендация:**

```java
// Если нет кастомной конфигурации Redis, можно перенести аннотацию
// в основной класс приложения или в любой другой @Configuration класс

@SpringBootApplication
@EnableRedisHttpSession
public class CloudStorageApplication {
    public static void main(String[] args) {
        SpringApplication.run(CloudStorageApplication.class, args);
    }
}
```

### Пакет /controller

1. **AuthController создаёт DTO напрямую**

В методе `doRegister` контроллер создаёт `UserDto` используя конструктор: `new UserDto(registerResponseDto.getUsername())`. Это нарушает инкапсуляцию и размазывает логику маппинга.

 контроллер знает внутреннюю структуру DTO. При изменении структуры `UserRegisterResponseDto` или `UserDto` придётся менять контроллер. Дублируется логика преобразования, если такой же маппинг нужен в других местах.

**Рекомендация:**

Есть 2 варианта, либо создавать исскуственные маперы как в примере ниже, либо использовать MapStruct что предпочтительнее и используется в реальной работе 
```java
// Добавить в UserDto
public record UserDto(String username) {
    public static UserDto from(UserRegisterResponseDto response) {
        return new UserDto(response.getUsername());
    }
    
    public static UserDto from(String username) {
        return new UserDto(username);
    }
}

// В AuthController
@PostMapping("/sign-up")
@ResponseStatus(HttpStatus.CREATED)
public UserDto doRegister(@Valid @RequestBody UserRegisterRequestDto dto) {
    UserRegisterResponseDto response = authService.register(dto);
    return UserDto.from(response);
}
```

2. **Контроллеры используют разные имена для одного и того же сервиса**

`DirectoryController` называет зависимость `minioService`, но это `StorageService`. В `ResourceController` и `DownloadController` то же самое. Это вводит в заблуждение.

 нарушается принцип наименьшего удивления — название переменной не соответствует типу. Снижается читаемость кода. При поиске использований `StorageService` можно пропустить эти контроллеры.

**Рекомендация:**

```java
@RestController
@RequestMapping("/api/directory")
@RequiredArgsConstructor
public class DirectoryController implements DirectoryApi {
    private final StorageService storageService; // вместо minioService
    
    @Override
    @GetMapping
    public List<ResourceDto> getDirectoryInfo(@RequestParam String path, 
                                               @AuthenticationPrincipal UserDetailsImpl user) {
        return storageService.getDirectoryInfo(path, user.getUserId());
    }
}

// Применить аналогично в ResourceController и DownloadController
```

3. **ResourceController имеет опечатку в названии метода**

Метод `searchByNane` содержит опечатку, наверное `searchByName`.

4. **DownloadController использует @Controller вместо @RestController**

`DownloadController` помечен аннотацией `@Controller` и имеет `@ResponseBody` на методе. Это избыточно.

**Рекомендация:**
Используй `@RestController`

5. **Отсутствует валидация параметра path**

Контроллеры принимают параметр `path` без валидации. Пользователь может передать пустую строку, null, или путь с недопустимыми символами (например, `../../../etc/passwd`).

 потенциальная уязвимость безопасности — path traversal атака. Отсутствие валидации на уровне контроллера приводит к нечитаемым ошибкам из слоя сервиса. Нарушается fail-fast principle.

**Рекомендация:**

Создать request dto и навесить туда валидацию джакарты, чтобы это спрингом сьедалось `@RequestParam` меняем на `@ModelAttribute` и добавляем `@Valid` (иначе валидация не запустится)
```java
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;

public class UploadRequest {

    @NotBlank(message = "path не должен быть пустым")
    @Size(max = 512, message = "path слишком длинный")
    // запрещаем '..' (path traversal)
    @Pattern(regexp = "^(?!.*\\.{2}).*$", message = "path не должен содержать '..'")
    // разрешаем только безопасные символы
    @Pattern(regexp = "^[a-zA-Z0-9/_\\.-]+$", message = "path содержит недопустимые символы")
    private String path;

    public String getPath() {
        return path;
    }

    public void setPath(String path) {
        this.path = path;
    }
}


@GetMapping
public ResourceDto getResource(@Valid @ModelAttribute UploadRequest request, 
                               @AuthenticationPrincipal UserDetailsImpl user) {
    return storageService.getResourceInfo(path, user.getUserId());
}
```

### Пакет /dto

1. **UserRegisterRequestDto и UserRegisterResponseDto используют @Data**

На DTO используется Lombok `@Data`, который генерирует `equals()`, `hashCode()`, `toString()` по всем полям, включая `password`.

 пароль попадёт в `toString()` и может утечь в логи. `@Data` генерирует сеттеры, что нарушает immutability DTO. DTO должны быть неизменяемыми после создания.

**Рекомендация:** Для Request и Response DTO использовать record

2. **ResourceDto использует @Data + @Builder + кастомный конструктор**

`ResourceDto` имеет `@Data`, `@AllArgsConstructor`, `@Builder` и отдельный кастомный конструктор. Это создаёт неоднозначность в способах создания объекта.

 множество способов создания объекта усложняет понимание кода. `@Data` генерирует сеттеры, что нарушает immutability. Два конструктора могут привести к ошибкам при использовании.

**Рекомендация:** для дто либо рекорды либо `@AllArgsConstructor` **и** `@NoArgsConstructor`

3. **Отсутствуют примеры в Swagger для DTO**

В API интерфейсах есть аннотации `@Schema`, но в самих DTO отсутствуют примеры значений для Swagger документации.

 Swagger UI не показывает примеры значений для полей DTO, что затрудняет использование API для фронтенд разработчиков. Нет демонстрации ожидаемого формата данных.

**Рекомендация:**

```java
public record UserRegisterRequestDto(
        @Schema(description = "Логин пользователя", example = "john_doe")
        @NotBlank(message = "Заполните поле логин")
        @Size(min = 5, max = 20)
        String username,
        
        @Schema(description = "Пароль пользователя", example = "SecurePass123")
        @NotBlank(message = "Заполните поле пароль")
        @Size(min = 5, max = 20)
        String password
) {}

@Schema(description = "Информация о файле или папке")
public class ResourceDto {
    @Schema(description = "Имя ресурса", example = "document.pdf")
    private String name;
    
    @Schema(description = "Тип ресурса")
    private Type type;
    
    @Schema(description = "Путь к ресурсу", example = "work/projects/")
    private String path;
    
    @Schema(description = "Размер файла в байтах", example = "1024000")
    private Long size;
}
```

### Пакет /exception

1. **AuthException слишком общее исключение**

### **Это скорее не ошибка, а рекомендация**

`AuthException` — очень общее название и может использоваться для разных типов ошибок аутентификации (неверные credentials, истёкший токен, заблокированный пользователь).

Одно исключение для разных ошибок не позволяет гибко обрабатывать их на уровне handler'а если хочется. Невозможно вернуть разные HTTP статусы или сообщения для разных типов auth ошибок если потребуется.

**Рекомендация:**

```java
// Создать базовый класс для auth исключений
public abstract class AuthenticationException extends RuntimeException {
    protected AuthenticationException(String message) {
        super(message);
    }
    
    protected AuthenticationException(String message, Throwable cause) {
        super(message, cause);
    }
}

// Конкретные исключения
public class InvalidCredentialsException extends AuthenticationException {
    public InvalidCredentialsException() {
        super("Неверный логин или пароль");
    }
}

public class AccountLockedException extends AuthenticationException {
    public AccountLockedException(String username) {
        super("Аккаунт заблокирован: " + username);
    }
}

// Handler может обрабатывать базовое исключение или конкретные
@ExceptionHandler(AuthenticationException.class)
@ResponseStatus(HttpStatus.UNAUTHORIZED)
public ErrorDto handleAuthException(AuthenticationException e) {
    return new ErrorDto(e.getMessage());
}
```

### Пакет /handler

1. **AppExceptionHandler использует @AuthenticationPrincipal в параметрах**

Методы обработки исключений принимают `@AuthenticationPrincipal UserDetailsImpl user`, но пользователь может быть не аутентифицирован (например, при ошибке на публичных эндпоинтах).

 `@AuthenticationPrincipal` может быть null для неавторизованных запросов, что требует null-checks. Это усложняет код handler'а и приводит к дублированию методов `getUsername()` и `getId()`.

**Рекомендация:**

```java
@RestControllerAdvice
public class AppExceptionHandler {
    
    // Использовать SecurityContextHolder напрямую или Optional
    @ExceptionHandler(FileNotFoundException.class)
    @ResponseStatus(HttpStatus.NOT_FOUND)
    public ErrorDto handleFileNotFound(FileNotFoundException e,
                                       HttpServletRequest request) {
        UserInfo userInfo = getCurrentUserInfo();
        
        log.warn("Пользователь {} (id={}) пытался получить несуществующий файл. Путь: {}. URL: {}",
                userInfo.username(), 
                userInfo.id(), 
                e.getPath(),
                request.getRequestURI());
        
        return new ErrorDto(e.getMessage());
    }
    
    private UserInfo getCurrentUserInfo() {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        if (auth != null && auth.getPrincipal() instanceof UserDetailsImpl user) {
            return new UserInfo(user.getUsername(), user.getUserId());
        }
        return new UserInfo("anonymous", null);
    }
    
    private record UserInfo(String username, Long id) {}
}
```

2. **Handler логирует message из BindingResult, но только первое сообщение**

В `handleMethodArgumentNotValidException` берётся только первая ошибка: `bindingResult.getAllErrors().getFirst().getDefaultMessage()`. Остальные ошибки валидации игнорируются.

 пользователь не видит все ошибки валидации сразу, а только первую. Плохой UX — приходится исправлять ошибки по одной и повторно отправлять запрос.

**Рекомендация:**

```java
@ExceptionHandler(MethodArgumentNotValidException.class)
@ResponseStatus(HttpStatus.BAD_REQUEST)
public ErrorDto handleValidationException(MethodArgumentNotValidException ex) {
    List<String> errors = ex.getBindingResult()
            .getAllErrors()
            .stream()
            .map(DefaultMessageSourceResolvable::getDefaultMessage)
            .toList();
    
    String message = String.join("; ", errors);
    log.error("Ошибки валидации: {}", message);
    
    return new ErrorDto(message);
}

// Или вернуть структурированный ответ
public record ValidationErrorDto(
        String message,
        Map<String, String> fieldErrors
) {}

@ExceptionHandler(MethodArgumentNotValidException.class)
@ResponseStatus(HttpStatus.BAD_REQUEST)
public ValidationErrorDto handleValidation(MethodArgumentNotValidException ex) {
    Map<String, String> errors = new HashMap<>();
    
    ex.getBindingResult().getFieldErrors().forEach(error ->
        errors.put(error.getField(), error.getDefaultMessage())
    );
    
    return new ValidationErrorDto("Ошибка валидации", errors);
}
```

3. **IllegalArgumentException обрабатывается с HTTP 409 Conflict**

`handleIllegalArgument` возвращает статус `409 CONFLICT`, но `IllegalArgumentException` обычно означает некорректные входные данные, что соответствует `400 BAD_REQUEST`.

 неправильный HTTP статус вводит в заблуждение API клиентов. 409 Conflict означает конфликт ресурсов (например, дублирование), а не некорректные аргументы. Фронтенд может неправильно обрабатывать такие ошибки.

**Рекомендация:**

```java
@ExceptionHandler(IllegalArgumentException.class)
@ResponseStatus(HttpStatus.BAD_REQUEST) // вместо CONFLICT
public ErrorDto handleIllegalArgument(IllegalArgumentException e,
                                      HttpServletRequest request) {
    UserInfo user = getCurrentUserInfo();
    
    log.error("Некорректные аргументы запроса. Пользователь {} (id={}). URL: {}", 
            user.username(), user.id(), request.getRequestURI());
    
    return new ErrorDto(e.getMessage());
}
```

4. **Отсутствует обработка специфичных Spring исключений**

Handler не обрабатывает такие частые исключения как `HttpMessageNotReadableException` (некорректный JSON), `MissingServletRequestParameterException` (отсутствует обязательный параметр), `TypeMismatchException` (неверный тип параметра).

 эти исключения попадут в общий `handleException`, который возвращает невнятное сообщение "Возникла непредвиденная ошибка". Пользователь не понимает, что он сделал не так.

**Рекомендация:**

```java
@ExceptionHandler(HttpMessageNotReadableException.class)
@ResponseStatus(HttpStatus.BAD_REQUEST)
public ErrorDto handleJsonParseException(HttpMessageNotReadableException e) {
    log.error("Ошибка парсинга JSON: {}", e.getMessage());
    return new ErrorDto("Некорректный формат JSON");
}

@ExceptionHandler(MissingServletRequestParameterException.class)
@ResponseStatus(HttpStatus.BAD_REQUEST)
public ErrorDto handleMissingParameter(MissingServletRequestParameterException e) {
    String message = String.format("Отсутствует обязательный параметр: %s", 
                                   e.getParameterName());
    log.error(message);
    return new ErrorDto(message);
}

@ExceptionHandler(MethodArgumentTypeMismatchException.class)
@ResponseStatus(HttpStatus.BAD_REQUEST)
public ErrorDto handleTypeMismatch(MethodArgumentTypeMismatchException e) {
    String message = String.format("Неверный формат параметра '%s'", e.getName());
    log.error(message);
    return new ErrorDto(message);
}
```

### Пакет /mapper

1. **ResourceDtoMapper не имеет private конструктора**

`ResourceDtoMapper` объявлен как `final class` с только статическими методами, но не имеет приватного конструктора.

Утил класс может быть создан через конструктор по умолчанию, хотя его экземпляры не имеют смысла. Это не соответствует best practices для utility классов.

**Рекомендация:**

Лучше для маппинга использовать MapStruct, если нет, то хотя бы добавить приват конструктор

```java
public final class ResourceDtoMapper {
    
    private ResourceDtoMapper() {
        throw new UnsupportedOperationException("Utility class");
    }
    
    .....
}
```

2. **Дублирование логики определения isDir**

В трёх перегруженных методах `toResourceDto` дублируется логика определения `isDir` по наличию `/` в конце пути.
```java
boolean isDir;
ResourceDto.Type type;

if (object.object().lastIndexOf("/") == object.object().length() - 1) {
    type = ResourceDto.Type.DIRECTORY;
    isDir = true;
} else {
    type = ResourceDto.Type.FILE;
    isDir = false;
}
```
Дублирование кода нарушает DRY. При изменении логики определения директории придётся менять в нескольких местах. Повышается вероятность ошибки.

**Рекомендация:**

```java
public final class ResourceDtoMapper {
    
    private ResourceDtoMapper() {
        throw new UnsupportedOperationException("Utility class");
    }
    
    public static ResourceDto toResourceDto(Item item) {
        return buildResourceDto(
            item.objectName(),
            item.isDir(),
            item.size()
        );
    }
    
    public static ResourceDto toResourceDto(StatObjectResponse object) {
        String path = object.object();
        boolean isDir = isDirectory(path);
        
        return buildResourceDto(path, isDir, object.size());
    }
    
    public static ResourceDto toResourceDto(ObjectWriteResponse object, Long size) {
        String path = object.object();
        boolean isDir = isDirectory(path);
        
        return buildResourceDto(path, isDir, size);
    }
    
    private static boolean isDirectory(String path) {
        return path.endsWith("/");
    }
    
    private static ResourceDto buildResourceDto(String path, boolean isDir, Long size) {
        ResourceDto.Type type = isDir ? ResourceDto.Type.DIRECTORY : ResourceDto.Type.FILE;
        
        return ResourceDto.builder()
                .name(MinioUtil.getName(path, isDir))
                .size(size)
                .type(type)
                .path(MinioUtil.getPath(path, isDir))
                .build();
    }
}
```

### Пакет /model

1. **Entity User имеет несогласованность полей с DTO**

В `User` поле называется `login`, а в DTO везде используется `username`. Это создаёт путаницу.

Несогласованность терминологии усложняет понимание кода. При маппинге между entity и DTO нужно помнить о разных названиях. При чтении кода неясно, `login` и `username` — это одно и то же или разные понятия.

**Рекомендация:**

Привести к общему названию, например `login`

2. **Отсутствуют audit поля**

В `User` нет стандартных полей аудита: `createdAt`, `updatedAt`. Невозможно отследить когда был создан пользователь или когда последний раз обновлялся.

Отсутствие аудита усложняет отладку и мониторинг. Невозможно реализовать функциональность "дата регистрации". Не соответствует best practices проектирования БД.

**Рекомендация:**

Стоит на любые объекты накидывать эти 2 поля и не забывать про них, могут однажды спасти тебя

```java
....
public class User {
    ....
    
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;
    
    @LastModifiedDate
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
}
//не забудь ликвибейз обновить тоже
```

### Пакет /repository

1. **UserRepository имеет избыточный модификатор public в методе**

Метод `findByLogin` объявлен как `public`, но в интерфейсе все методы по умолчанию public.

Избыточный код, снижает читаемость. В интерфейсах методы всегда public, явное указание не требуется, тебе даже идея это подсвечивает

### Пакет /security

1. **UserDetailsServiceImpl использует Optional.isEmpty() вместо orElseThrow**

В методе `loadUserByUsername` используется проверка `if (user.isEmpty())`, хотя можно использовать более идиоматичный `orElseThrow`.

Проблема isEmpty в том, что менее читаемый код, больше строк. Optional предоставляет метод `orElseThrow` специально для такого случая.

**Рекомендация:**

```java
@Service
@RequiredArgsConstructor
public class UserDetailsServiceImpl implements UserDetailsService {
    private final UserRepository userRepository;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException(
                    "Пользователь не найден: " + username
                ));

        return new UserDetailsImpl(
                user.getId(),
                user.getUsername(),
                user.getPassword()
        );
    }
}
```

### Пакет /service

1. **AuthService имеет закомментированный код**

В методе `authenticate` есть закомментированная строка `SecurityContextHolder.getContext().setAuthentication(auth)`.

Закомментированный код замусоривает кодовую базу. Непонятно, нужен ли этот код или его можно удалить. Если код был закомментирован для отладки, его не следует коммитить. Для истории изменений есть Git.

**Рекомендация:**

Удалить `// SecurityContextHolder.getContext().setAuthentication(auth);` либо раскоментировать


2. **StorageService.isFileAlreadyExist использует try-catch для проверки**

Метод `isFileAlreadyExist` использует исключение `FileNotFoundException` для управления потоком выполнения.

Использование исключений для control flow — антипаттерн. Исключения должны использоваться для исключительных ситуаций, а не для обычной логики. Это неэффективно (создание стектрейса) и снижает читаемость.

**Рекомендация:**

```java
// Добавить в StorageProvider метод без исключения
public interface StorageProvider {
    boolean exists(String path);
    // остальные методы
}

// В MinioStorageProvider
@Override
public boolean exists(String path) {
    try {
        minioClient.statObject(
                StatObjectArgs.builder()
                        .bucket(bucket)
                        .object(path)
                        .build()
        );
        return true;
    } catch (ErrorResponseException e) {
        if (e.errorResponse().code().equals("NoSuchKey")) {
            return false;
        }
        throw new MinioStorageException(LogMessage.EXCEPTION_MINIO_EXCEPTION, e, path);
    } catch (Exception e) {
        throw new MinioStorageException(LogMessage.EXCEPTION_MINIO_EXCEPTION, e, path);
    }
}

// В StorageService
private boolean isFileAlreadyExist(String path, Long id) {
    String fullPath = getUserFolderName(id) + "/" + path;
    return storageProvider.exists(fullPath);
}
```

3. **StorageService дублирует логику построения fullPath**

В каждом методе `StorageService` дублируется код `getUserFolderName(id) + "/" + path`.

Дублирование кода нарушает DRY. При изменении логики формирования пути придётся менять во многих местах

**Рекомендация:**

```java
@Service
@RequiredArgsConstructor
public class StorageService {
    private final StorageProvider storageProvider;

    public ResourceDto getResourceInfo(String path, Long userId) {
        String fullPath = buildFullPath(userId, path);
        return storageProvider.getResourceInfo(fullPath);
    }

    public List<ResourceDto> getDirectoryInfo(String path, Long userId) {
        String fullPath = buildFullPath(userId, path);
        return storageProvider.getDirectoryInfo(fullPath);
    }
    
    // Централизованный метод построения пути
    private String buildFullPath(Long userId, String path) {
        String userFolder = getUserFolderName(userId);
        
        if (path == null || path.isEmpty()) {
            return userFolder + "/";
        }
        
        // Нормализация пути
        String normalizedPath = path.startsWith("/") ? path.substring(1) : path;
        return userFolder + "/" + normalizedPath;
    }
    
    private String getUserFolderName(Long userId) {
        return "user-" + userId + "-files";
    }
}
```

4. **MinioStorageProvider аннотирован @Component вместо @Service**

`MinioStorageProvider` реализует бизнес-логику и должен быть `@Service`, но помечен как `@Component`.

Семантически неверно — `@Component` — это общая аннотация, `@Service` явно указывает на сервисный слой

5. **MinioStorageProvider.downloadFolder загружает всю папку в память**

Метод `downloadFolder` использует `ByteArrayOutputStream` для создания ZIP архива в памяти, что может привести к OutOfMemoryError при больших папках.

При архивировании большой папки (сотни мегабайт или гигабайты) весь контент загружается в память JVM. Это приведёт к падению приложения или очень долгой работе GC. Не масштабируемое решение.

**Рекомендация:**

```java
@Override
public InputStreamResource downloadFolder(String path) {
    // Использовать streaming вместо загрузки в память
    PipedOutputStream pipedOut = new PipedOutputStream();
    PipedInputStream pipedIn;
    
    try {
        pipedIn = new PipedInputStream(pipedOut);
    } catch (IOException e) {
        throw new MinioStorageException(LogMessage.EXCEPTION_MINIO_EXCEPTION, e, path);
    }
    
    // Асинхронно записывать в pipe
    CompletableFuture.runAsync(() -> {
        try (ZipOutputStream zip = new ZipOutputStream(pipedOut)) {
            Iterable<Result<Item>> items = minioClient.listObjects(
                    ListObjectsArgs.builder()
                            .bucket(bucket)
                            .prefix(path)
                            .recursive(true)
                            .build()
            );

            for (Result<Item> item : items) {
                String fileName = item.get().objectName();
                if (fileName.endsWith("/")) continue;
                
                String zipEntryName = fileName.substring(path.length());
                zip.putNextEntry(new ZipEntry(zipEntryName));

                try (InputStream in = minioClient.getObject(
                        GetObjectArgs.builder()
                                .bucket(bucket)
                                .object(fileName)
                                .build())) {
                    in.transferTo(zip);
                }
                zip.closeEntry();
            }
        } catch (Exception e) {
            log.error("Error creating ZIP archive", e);
        }
    });
    
    return new InputStreamResource(pipedIn);
}
```

6. **StorageService.uploadFile создаёт пустую папку после загрузки файла**

В методе `uploadFile` после загрузки файла создаётся пустая папка через `createEmptyFolder`, если её ещё нет. Это неоптимально — проверка и создание для каждого файла.

При загрузке множества файлов в одну папку метод `isFileAlreadyExist` будет вызываться для каждого файла. Это N лишних запросов к MinIO. Логика создания папки размазана по коду.

**Рекомендация:**

```java
public List<ResourceDto> uploadFile(MultipartFile[] files, String path, Long id) {
    List<ResourceDto> resourceDtos = new ArrayList<>();
    String userFolderName = getUserFolderName(id);
    
    // Создать папку один раз перед загрузкой файлов
    if (!path.isEmpty()) {
        String folderPath = buildFullPath(id, path + "/");
        if (!storageProvider.exists(folderPath)) {
            storageProvider.createEmptyFolder(folderPath);
        }
    }

    for (MultipartFile file : files) {
        String fileName = file.getOriginalFilename();
        String fullPath = buildFullPath(id, 
            path.isEmpty() ? fileName : path + "/" + fileName
        );

        if (storageProvider.exists(fullPath)) {
            throw new FileAlreadyExistsException(
                String.format(LogMessage.EXCEPTION_FILE_ALREADY_EXIST, fileName), 
                fullPath
            );
        }

        ResourceDto resourceDto = storageProvider.uploadFile(file, fullPath);
        resourceDtos.add(resourceDto);
    }
    
    return resourceDtos;
}
```

### Пакет /util

1. **MinioUtil не имеет private конструктора**

Выше писал про констркуторы в утил классах

2. **MinioUtil.getPath имеет неочевидную логику**

Метод `getPath` извлекает путь к родительской папке, но его название и логика неочевидны без документации.

Непонятно что делает метод без чтения реализации. Название `getPath` предполагает получение полного пути, а не родительской папки. Отсутствие JavaDoc усугубляет проблему.

**Рекомендация:**

Добавить джавадок и переименовать метод в `getParentPath`

### Пакет /test

1. **Большинство тестов закомментированы**

Файлы `CloudStorageApplicationTests.java` и `AuthControllerTest.java` полностью закомментированы.

**Рекомендация:**

Раскомментировать, если они не рабочие, переписать на рабочие

2. **Отсутствуют тесты для StorageService**

Нет ни одного теста для `StorageService` — самого важного компонента системы, отвечающего за работу с файлами.

`StorageService` содержит критическую бизнес-логику (upload, download, move, delete), которая должна быть покрыта тестами. Без тестов невозможно гарантировать корректность работы при рефакторинге или добавлении функциональности.

3. **Отсутствуют unit тесты для util классов**

Классы `MinioUtil` и `ResourceDtoMapper` не имеют тестов, хотя содержат нетривиальную логику обработки строк.

Утилитарные методы часто содержат edge cases (пустые строки, null, специальные символы), которые нужно тестировать. Ошибка в util методе может привести к багам во всех местах его использования.

5. **Нет интеграционных тестов для API endpoints**

Отсутствуют полноценные интеграционные тесты для REST API с реальными HTTP запросами.

Unit тесты не покрывают интеграцию всех слоёв (контроллер → сервис → хранилище). Невозможно проверить работу Spring Security, валидации, сериализации JSON. Не тестируется реальное поведение API.


### Инфраструктура (Docker, конфигурация)

1. **Dockerfile использует JDK вместо JRE в runtime**

В production образе используется `eclipse-temurin:21-jdk-jammy`, хотя для запуска приложения достаточно JRE.

JDK содержит компилятор и инструменты разработки, которые не нужны в runtime. Это увеличивает размер образа на 200-300 МБ и расширяет поверхность атаки.

**Рекомендация:**

```dockerfile
.....
# Использовать JRE вместо JDK
FROM eclipse-temurin:21-jre-jammy
.....
```

2. **Отсутствуют health checks в docker-compose**

В `docker-compose.yml` нет health checks для сервисов, что может привести к проблемам при старте.

Приложение может попытаться подключиться к БД или MinIO до того, как они будут готовы. Нет автоматического перезапуска при падении сервисов. Docker не знает реальное состояние контейнеров.

**Рекомендация:**

Изучить хелсчеки и добавить их

3. **Отсутствует .dockerignore**

В проекте нет файла `.dockerignore`, что приводит к копированию ненужных файлов в Docker контекст.

При сборке образа копируются `target/`, `.git/`, `.idea/`, `node_modules/` и другие ненужные директории. Это замедляет сборку и увеличивает размер контекста.

**Рекомендация:**

```
# .dockerignore
target/
.git/
.idea/
.vscode/
*.iml
.env
.DS_Store
node_modules/
*.log
```

4. **Docker compose не имеет network isolation**

Все сервисы находятся в дефолтной сети без явного определения networks.

Нет изоляции между сервисами. Все контейнеры могут общаться друг с другом. Нет возможности ограничить доступ (например, MinIO должен быть доступен только для app, но не для внешних запросов напрямую).

**Рекомендация:**

Полезно изучить на будущее, может пригодиться

```yaml
services:
  db:
    image: postgres:17
    networks:
      - backend
    # Не публиковать порт наружу в production
    # ports:
    #   - "5432:5432"
    # остальная конфигурация

  minio:
    image: minio/minio
    networks:
      - backend
    # Только console наружу
    ports:
      - "9001:9001"
    # остальная конфигурация

  redis:
    image: redis:7.2
    networks:
      - backend
    # остальная конфигурация

  app:
    build: .
    networks:
      - backend
    ports:
      - "8080:8080"
    # остальная конфигурация

networks:
  backend:
    driver: bridge
```

### Общие баги и недочёты

1. **Отсутствует проверка на null для MultipartFile.getOriginalFilename()**

В `StorageService.uploadFile` используется `file.getOriginalFilename()` без проверки на null, что может привести к NPE.

Согласно спецификации Servlet, `getOriginalFilename()` может вернуть null или пустую строку. При загрузке файла без имени приложение упадёт с NullPointerException.

2. **Отсутствует ограничение на размер имени файла**

Нет проверки на длину имени файла или пути, что может привести к ошибкам в MinIO или БД.

Очень длинное имя файла может превысить ограничения файловой системы или MinIO. При использовании пути в БД (например, для метаданных) можно превысить размер колонки.

3. **Метод moveResource делает copy + delete без транзакции**

В `StorageService.moveResource` сначала копируется ресурс, затем удаляется оригинал. Если удаление упадёт с ошибкой, файл будет продублирован.

Нет атомарности операции. При ошибке на этапе удаления файл останется и в старом, и в новом месте. Пользователь не поймёт что произошло. Невозможно откатить изменения.

**Рекомендация:**

```java
// MinIO SDK v8.5+ поддерживает атомарный rename для некоторых операций
// Но в общем случае нужна компенсирующая транзакция

private ResourceDto moveFile(String from, String to, Long id) {
    String fullSourcePath = getUserFolderName(id) + "/" + from;
    String fullTargetPath = getUserFolderName(id) + "/" + to;

    if (!isFileAlreadyExist(from, id)) {
        throw new FileNotFoundException(
            String.format(LogMessage.EXCEPTION_FILE_NOT_FOUND, from), 
            fullSourcePath
        );
    }
    
    if (isFileAlreadyExist(to, id)) {
        throw new FileAlreadyExistsException(
            String.format(LogMessage.EXCEPTION_FILE_ALREADY_EXIST, to), 
            fullTargetPath
        );
    }

    try {
        // Сначала копируем
        storageProvider.copyFile(fullSourcePath, fullTargetPath);
        
        // Затем удаляем оригинал
        storageProvider.deleteFile(fullSourcePath);
        
    } catch (Exception e) {
        // Если удаление упало, откатываем копирование
        try {
            if (storageProvider.exists(fullTargetPath)) {
                storageProvider.deleteFile(fullTargetPath);
                log.warn("Rollback: удалён скопированный файл после ошибки move: {}", fullTargetPath);
            }
        } catch (Exception rollbackEx) {
            log.error("Не удалось откатить операцию move. Файл продублирован.", rollbackEx);
        }
        throw e;
    }

    return getResourceInfo(to, id);
}
```

4. **ResourceController.move использует GET вместо PUT/PATCH**

Метод `move` использует HTTP метод GET, хотя это изменяющая операция.

Нарушение REST принципов — GET должен быть идемпотентным и не изменять состояние. Это ошибка в ТЗ, надо было задуматься

5. **Отсутствует валидация размера массива файлов**

В `uploadFile` принимается массив `MultipartFile[]` без ограничения количества файлов.

Пользователь может попытаться загрузить тысячи файлов за один запрос, что приведёт к перегрузке сервера или таймауту. Нет защиты от DoS атаки.п

## РЕКОМЕНДАЦИИ

1. **Ввести слой DTO мапперов с использованием MapStruct**

Сейчас маппинг между entity и DTO происходит вручную в разных местах кода. Рекомендуется использовать MapStruct для автоматической генерации мапперов, что снизит boilerplate код и уменьшит вероятность ошибок.

2. **Добавить пагинацию для операций listing**

Методы `getDirectoryInfo` и `search` возвращают все результаты без пагинации. При большом количестве файлов это приведёт к проблемам с производительностью и памятью. Рекомендуется добавить поддержку `Pageable` параметра.

3. **Выделить отдельный слой для MinIO Client API**

`MinioStorageProvider` напрямую работает с `MinioClient`. Рекомендуется создать дополнительный слой абстракции (например, `MinioClientWrapper`), который будет инкапсулировать все вызовы SDK и обработку его исключений. Это упростит тестирование и замену реализации.

4. **Использовать аспекты для логирования**

Сейчас логирование размазано по коду. Рекомендуется использовать Spring AOP для централизованного логирования входов/выходов методов сервисного слоя, параметров запросов и времени выполнения.

5. **Добавить кеширование для часто запрашиваемых ресурсов**

Метаданные файлов (размер, имя, тип) можно кешировать с помощью Spring Cache (например, в Redis). Это снизит нагрузку на MinIO и ускорит работу API.

6. **Внедрить стратегию для storage providers**

Сейчас есть интерфейс `StorageProvider`, но только одна реализация. Рекомендуется добавить Strategy Pattern с возможностью выбора storage provider через конфигурацию (MinIO, S3, local filesystem), что повысит гибкость системы.

7. **Добавить rate limiting**

Рекомендуется ограничить количество запросов от одного пользователя (особенно для upload/download операций) с использованием Bucket4j или Redis rate limiter для защиты от злоупотреблений.

8. **Реализовать асинхронную обработку загрузки больших файлов**

Для загрузки больших файлов рекомендуется использовать асинхронную обработку с возвратом task ID и endpoint'ом для проверки статуса. Это улучшит отзывчивость API и предотвратит таймауты.

9. **Добавить механизм quota (квоты на пространство)**

Рекомендуется добавить в модель `User` поле с лимитом дискового пространства и механизм проверки при загрузке файлов. Это позволит контролировать использование ресурсов.

10. **Вынести строковые константы путей в конфигурацию**

Шаблон `"user-{id}-files"` захардкожен в коде. Рекомендуется вынести в `application.yml` с поддержкой плейсхолдеров:
```yaml
storage:
  user-folder-pattern: "user-{userId}-files"
```

11. **Добавить health checks для внешних зависимостей**

Рекомендуется реализовать Spring Boot Actuator health indicators для MinIO, Redis и PostgreSQL, чтобы мониторить доступность сервисов.

12. **Использовать Resilience4j для устойчивости**

Добавить Circuit Breaker, Retry и Timeout политики для вызовов MinIO API. Это повысит устойчивость системы при временных проблемах с внешними сервисами.

## ИТОГ

Проект реализован на среднем уровне, но содержит серьёзные проблемы безопасности и производительности, из-за которых не готов к использованию в production.

Проект демонстрирует понимание Spring Boot, REST API и работы с внешними сервисами (MinIO, Redis, PostgreSQL). Среди плюсов — record для immutable DTO, профили dev/prod, Spring Security, Liquibase и контейнеризация.

В то же время присутствуют критичные недостатки: отсутствие валидации входных данных (Path Traversal), риск утечки паролей в логах, отсутствие ограничений на загрузку файлов (DoS), загрузка больших данных целиком в память. Также есть архитектурные проблемы — дублирование кода, слабая обработка ошибок и малое количество тестов.

Проект требует устранения проблем безопасности и производительности, упрощения архитектуры и добавления тестового покрытия перед дальнейшим развитием.
